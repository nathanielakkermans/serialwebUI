<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamische SeriÃ«le Sensor en Configuratie</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        /* Stijl voor de Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            max-width: 95%;
            max-height: 95%;
            width: 900px; 
            background: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            overflow: auto; 
        }

        /* Stijl voor geselecteerde kaart */
        .sensor-card-selected {
            border-color: #6366f1; /* Tailwind indigo-500 */
            box-shadow: 0 4px 6px rgba(99, 102, 241, 0.3); 
        }

        /* STERKERE VERVAGING BIJ DISCONNECTIE */
        .data-stale .sensor-card, .data-stale .message-card {
            opacity: 0.3; 
            filter: blur(1.5px); 
            transition: opacity 0.5s, filter 0.5s;
        }
        
        /* Stijl voor de zwevende melding (Toast) */
        #toastNotification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(-10px);
            opacity: 0;
            max-width: 300px;
        }
        #toastNotification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Stijl voor actieve Tab */
        .tab-active {
            border-bottom: 3px solid #6366f1; /* indigo-500 */
            color: #4338ca; /* indigo-700 */
            font-weight: 600;
        }

        /* Stijl voor instelling met wijziging */
        .setting-changed {
            background-color: #fffbeb; /* yellow-50 */
            border-left: 5px solid #f59e0b; /* amber-500 */
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8">

    <div id="toastNotification" class="hidden p-4 rounded-lg shadow-xl" role="alert">
        <p id="toastText" class="font-medium text-sm"></p>
    </div>

    <div class="max-w-full xl:max-w-screen-2xl mx-auto bg-white shadow-xl rounded-xl p-6 sm:p-10">
        
        <header class="mb-4 border-b pb-4">
            
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center">
                <div>
                    <h1 class="text-3xl font-extrabold text-indigo-700">SeriÃ«le Apparaat Controller</h1>
                    <p class="text-gray-500 mt-1">Monitor en configureer uw seriÃ«le apparaat via JSON.</p>
                </div>
                
                <div id="connectionControls" class="mt-4 sm:mt-0 flex items-center space-x-4">
                    
                    <div id="baudRateWrapper" class="flex items-center space-x-1">
                        <label for="baudRateSelect" class="text-xs font-medium text-gray-700 whitespace-nowrap hidden lg:inline">Baud:</label>
                        <select id="baudRateSelect" class="py-1 px-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-sm w-24">
                            <option value="115200" selected>115200</option>
                            <option value="250000">250000</option>
                            <option value="500000">500000</option>
                            <option value="1000000">1000000</option>
                        </select>
                    </div>
                    
                    <button id="connectButton"
                            class="px-3 py-1 bg-indigo-500 text-white font-semibold text-sm rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 ease-in-out disabled:opacity-50"
                            onclick="connectSerialPort()">
                        Verbind
                    </button>

                    <div id="statusMessage" class="font-medium text-sm text-gray-600 whitespace-nowrap">
                        Klaar om te verbinden.
                    </div>
                </div>
            </div>
            
            <div class="flex mt-4 space-x-6">
                <button id="tabMonitor" onclick="setActiveTab('monitor')" class="py-2 text-gray-500 hover:text-indigo-700 transition tab-active">
                    Monitor
                </button>
                <button id="tabSettings" onclick="setActiveTab('settings')" class="py-2 text-gray-500 hover:text-indigo-700 transition">
                    Instellingen
                </button>
            </div>
        </header>

        <main id="monitorView" class="space-y-6">
             <div class="flex justify-start items-center space-x-4 mb-6">
                <button id="clearGraphButton"
                        class="px-3 py-1 bg-gray-400 text-white font-semibold text-sm rounded-lg shadow-md transition duration-150 ease-in-out disabled:opacity-50"
                        onclick="clearGraphSelection()"
                        disabled>
                    Grafiek Deselecteren
                </button>

                <button id="openChartButton"
                        class="px-3 py-1 bg-gray-400 text-white font-semibold text-sm rounded-lg shadow-md transition duration-150 ease-in-out disabled:opacity-50"
                        onclick="openMultiSensorGraph()"
                        disabled>
                    Toon Grafiek (0)
                </button>
            </div>
            <div id="sensorContainer" class="space-y-6">
                <div id="initialMessage" class="text-center text-gray-500 p-8 border-2 border-dashed border-gray-300 rounded-lg">
                    Wacht op sensor data... Zorg ervoor dat u verbonden bent.
                </div>
            </div>
        </main>
        
        <div id="settingsView" class="hidden space-y-6">
            <div id="settingsHeader" class="flex justify-between items-center bg-gray-100 p-4 rounded-lg shadow-sm">
                <p id="settingsStatus" class="text-sm text-gray-600">Instellingen ontvangen van apparaat. Klik op 'Update Instellingen' om wijzigingen te verzenden.</p>
                <button id="sendSettingsButton" 
                        onclick="sendAllChangedSettings()"
                        class="px-4 py-2 bg-indigo-500 text-white font-semibold text-sm rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 ease-in-out disabled:opacity-50"
                        disabled>
                    Update Instellingen (0)
                </button>
            </div>
            
            <div id="settingsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <div id="initialSettingsMessage" class="md:col-span-3 text-center text-gray-500 p-8 border-2 border-dashed border-gray-300 rounded-lg">
                    Wacht op instellingsdefinities van het seriÃ«le apparaat.
                </div>
            </div>
        </div>

    </div>

    <div id="graphModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h2 id="graphModalTitle" class="text-xl font-bold text-gray-800">Geselecteerde Sensorgrafieken</h2>
                <button onclick="closeGraphModal()" class="p-2 rounded-full hover:bg-gray-100 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x text-gray-500"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>

            <div class="flex justify-between items-center mb-4">
                <div id="timescaleButtons" class="flex justify-start space-x-2">
                    <button onclick="updateChart('60000')" data-duration="60000" class="px-4 py-1 rounded-lg text-sm font-medium transition duration-150 ease-in-out bg-indigo-600 text-white">1 Minuut</button>
                    <button onclick="updateChart('300000')" data-duration="300000" class="px-4 py-1 rounded-lg text-sm font-medium transition duration-150 ease-in-out bg-gray-200 text-gray-700 hover:bg-gray-300">5 Minuten</button>
                    <button onclick="updateChart('900000')" data-duration="900000" class="px-4 py-1 rounded-lg text-sm font-medium transition duration-150 ease-in-out bg-gray-200 text-gray-700 hover:bg-gray-300">15 Minuten</button>
                </div>
                
                <button id="exportCsvButton" onclick="downloadRawSelectedData()"
                        class="px-4 py-1 bg-emerald-500 text-white font-semibold text-sm rounded-lg shadow-md hover:bg-emerald-600 transition duration-150 ease-in-out disabled:opacity-50">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 11.586V3a1 1 0 112 0v8.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    Exporteer Geselecteerde Data
                </button>
            </div>


            <div class="relative h-96">
                <canvas id="sensorChart"></canvas>
            </div>
            
            <div id="chartLegend" class="mt-6 p-3 bg-gray-50 rounded-lg border border-gray-200 text-sm">
                <p class="font-semibold mb-2 text-gray-700">Geselecteerde Sensoren:</p>
                </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Vaste Canvas variabelen
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth;

        // Functie om Firebase te initialiseren en in te loggen
        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.warn("Firebase configuratie ontbreekt. Functies die database vereisen zullen niet werken.");
                    return;
                }
                setLogLevel('debug');
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("Aangemeld met aangepaste token.");
                } else {
                    await signInAnonymously(auth);
                    console.log("Anoniem aangemeld.");
                }
            } catch (error) {
                console.error("Fout bij Firebase initialisatie of authenticatie:", error);
            }
        }

        initializeFirebase();

        // ----------------------------------------------------
        // SeriÃ«le Communicatie en UI Logica
        // ----------------------------------------------------

        // Globale variabelen voor seriÃ«le status en data
        let port;
        let reader;
        let writer;
        let activeChart = null; // Chart.js instantie
        let sensorData = {}; // { "CategoryName": [sensor1, sensor2, ...], ... }
        let selectedSensors = []; // Array van { category, name } objecten
        let toastTimeout = null;
        let isConnected = false; // Houdt de verbindingsstatus bij
        
        // Configuratie (Nieuw)
        let settingsDefinition = {}; // De definitie van alle instellingen (van apparaat)
        let settingsChanged = new Set(); // Set van ID's die gewijzigd zijn in de UI

        const statusMessageEl = document.getElementById('statusMessage');
        const connectButton = document.getElementById('connectButton');
        const openChartButton = document.getElementById('openChartButton');
        const clearGraphButton = document.getElementById('clearGraphButton'); 
        const sensorContainerEl = document.getElementById('sensorContainer');
        const initialMessageEl = document.getElementById('initialMessage');
        const baudRateSelectEl = document.getElementById('baudRateSelect'); 
        const baudRateWrapperEl = document.getElementById('baudRateWrapper');
        const chartLegendEl = document.getElementById('chartLegend');
        const toastNotificationEl = document.getElementById('toastNotification');
        const toastTextEl = document.getElementById('toastText');
        
        // Configuratie elementen (Nieuw)
        const settingsContainerEl = document.getElementById('settingsContainer');
        const initialSettingsMessageEl = document.getElementById('initialSettingsMessage');
        const sendSettingsButtonEl = document.getElementById('sendSettingsButton');

        // GLOBALE VARIABELEN VOOR RENDERING THROTTLING
        let needsRender = false;
        let renderTimeout = null;
        const RENDER_INTERVAL = 100; // Max 10 FPS
        let activeTab = 'monitor'; // Huidige actieve tab

        // Kleuren voor de grafiek lijnen (Tailwind palet)
        const CHART_COLORS = [
            'rgb(79, 70, 229)',  // Indigo
            'rgb(234, 179, 8)',  // Yellow
            'rgb(239, 68, 68)',  // Red
            'rgb(16, 185, 129)', // Emerald
            'rgb(59, 130, 246)', // Blue
            'rgb(168, 85, 247)', // Violet
        ];

        /**
         * Schakelt tussen de Monitor en Instellingen weergave. (Nieuw)
         */
        window.setActiveTab = function(tab) {
            activeTab = tab;
            document.getElementById('monitorView').classList.toggle('hidden', tab !== 'monitor');
            document.getElementById('settingsView').classList.toggle('hidden', tab !== 'settings');
            
            document.getElementById('tabMonitor').classList.toggle('tab-active', tab === 'monitor');
            document.getElementById('tabSettings').classList.toggle('tab-active', tab === 'settings');

            if (tab === 'settings') {
                // Her-render de instellingen om de laatste staat te tonen
                renderSettingsControls();
            }
        };
        
        /**
         * Update de statusboodschap en styling.
         */
        function updateStatus(message, state = 'default') {
            statusMessageEl.textContent = message;
            statusMessageEl.className = 'font-medium text-sm whitespace-nowrap transition duration-300';

            switch (state) {
                case 'connected':
                    statusMessageEl.classList.add('text-green-600');
                    break;
                case 'connecting':
                    statusMessageEl.classList.add('text-yellow-600');
                    break;
                case 'error':
                    statusMessageEl.classList.add('text-red-600');
                    break;
                case 'default':
                default:
                    statusMessageEl.classList.add('text-gray-600');
                    break;
            }
        }

        /**
         * Schakelt de visuele vervaging van de sensorwaarden in/uit.
         */
        function toggleDataStale() {
            if (isConnected) {
                sensorContainerEl.classList.remove('data-stale');
                document.getElementById('settingsView').classList.remove('data-stale');
            } else {
                sensorContainerEl.classList.add('data-stale');
                document.getElementById('settingsView').classList.add('data-stale');
            }
        }

        /**
         * Update de "Toon Grafiek" en "Grafiek Deselecteren" knoppen met het aantal geselecteerde sensoren.
         */
        function updateChartButtonState() {
            const count = selectedSensors.length;
            openChartButton.textContent = `Toon Grafiek (${count})`;
            openChartButton.disabled = count === 0;
            clearGraphButton.disabled = count === 0; 
            
            clearGraphButton.textContent = `Grafiek Deselecteren`;

            // Toon Grafiek (Emerald 500)
            openChartButton.classList.toggle('bg-emerald-500', count > 0);
            openChartButton.classList.toggle('hover:bg-emerald-600', count > 0);
            openChartButton.classList.toggle('bg-gray-400', count === 0);
            openChartButton.classList.toggle('hover:bg-gray-400', count === 0);

            // Grafiek Deselecteren (Rose 500)
            clearGraphButton.classList.toggle('bg-rose-500', count > 0);
            clearGraphButton.classList.toggle('hover:bg-rose-600', count > 0);
            clearGraphButton.classList.toggle('bg-gray-400', count === 0);
            clearGraphButton.classList.toggle('hover:bg-gray-400', count === 0);
        }
        
        /**
         * Maakt de selectie van alle sensoren leeg.
         */
        window.clearGraphSelection = function() {
            if (selectedSensors.length === 0) return;

            selectedSensors = [];
            
            // Sluit de grafiek modal als deze open is
            const modal = document.getElementById('graphModal');
            if (!modal.classList.contains('hidden')) {
                closeGraphModal();
            }

            updateChartButtonState();
            updateSensorDisplays(); // Zorgt voor het visueel deselecteren van de kaarten
            showMessage('Grafiek selectie gedeselecteerd.', false);
        }

        /**
         * Update de UI met de huidige sensorData, maar op een gethrottlede manier.
         */
        function throttleRenderUI() {
            if (renderTimeout) return; 

            renderTimeout = setTimeout(() => {
                if (needsRender) {
                    updateSensorDisplays();
                    // Zorg ervoor dat instellingen ook geÃ¼pdatet worden als de tab actief is
                    if (activeTab === 'settings') {
                         renderSettingsControls();
                    }
                    needsRender = false;
                }
                renderTimeout = null;
            }, RENDER_INTERVAL);
        }
        
        /**
         * Helper functie om een unieke, veilige ID te maken.
         */
        function makeSensorId(category, name) {
            return `${category.replace(/\s/g, '_')}-${name.replace(/\s/g, '_')}`;
        }
        
        /**
         * Helper functie om een unieke sleutel te maken voor opslag in selectedSensors.
         */
        function makeSensorKey(category, name) {
            return `${category}|${name}`;
        }

        /**
         * Zoek een sensor object op basis van de sleutel.
         */
        function getSensorByKey(key) {
            const [category, name] = key.split('|');
            return sensorData[category]?.find(s => s.name === name);
        }

        /**
         * Toggle de selectie status van een sensor voor de grafiek.
         */
        function toggleSensorSelection(category, name) {
            const key = makeSensorKey(category, name);
            const sensor = getSensorByKey(key);
            
            // Alleen numerieke sensoren toestaan in de grafiek
            if (sensor && sensor.type === 'text') {
                 showMessage("Alleen numerieke sensorwaarden kunnen worden geselecteerd voor de grafiek.", true);
                 return;
            }

            const index = selectedSensors.findIndex(s => makeSensorKey(s.category, s.name) === key);

            if (index > -1) {
                // Deselecteren
                selectedSensors.splice(index, 1);
            } else {
                // Selecteren
                selectedSensors.push({ category, name });
            }

            updateChartButtonState();
            updateSensorDisplays(); 
        }


        /**
         * Functie om de DOM-elementen gericht bij te werken (Patchen).
         */
        function updateSensorDisplays() {
            const categories = Object.keys(sensorData);
            
            if (categories.length > 0 && initialMessageEl) {
                initialMessageEl.classList.add('hidden');
            }

            // ... (Bestande updateSensorDisplays logica blijft hier ongewijzigd) ...
            
            categories.forEach(category => {
                const sensors = sensorData[category];
                const categoryId = category.replace(/\s/g, '_');
                const gridId = `grid-${categoryId}`;
                
                let categoryGroupEl = document.getElementById(`category-${categoryId}`);
                if (!categoryGroupEl) {
                    categoryGroupEl = document.createElement('div');
                    categoryGroupEl.id = `category-${categoryId}`;
                    categoryGroupEl.className = 'category-group bg-gray-50 p-5 rounded-xl shadow-lg';
                    categoryGroupEl.innerHTML = `
                        <h2 class="text-2xl font-bold mb-4 text-gray-800 border-b pb-2">${category}</h2>
                        <div id="${gridId}" class="sensor-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-4">
                        </div>
                    `;
                    sensorContainerEl.appendChild(categoryGroupEl);
                }
                
                const gridEl = document.getElementById(gridId);

                sensors.forEach(sensor => {
                    const sensorId = makeSensorId(category, sensor.name);
                    let sensorCardEl = document.getElementById(sensorId);

                    if (sensor.type === 'text') {
                        // --- TEKST BERICHT KAART RENDERING ---
                        const latestEntry = sensor.history.length > 0 ? sensor.history[sensor.history.length - 1] : null;
                        const latestMessage = latestEntry ? latestEntry.value : 'Geen bericht ontvangen';
                        const latestTime = latestEntry ? new Date(latestEntry.time).toLocaleTimeString('nl-NL') : 'N/A';
                        
                        if (!sensorCardEl || sensorCardEl.classList.contains('sensor-card')) {
                             if (sensorCardEl) sensorCardEl.remove();

                            // CreÃ«er NIEUWE tekst kaart
                            sensorCardEl = document.createElement('div');
                            sensorCardEl.id = sensorId;
                            // Geen data-action="toggle-select" voor tekst
                            sensorCardEl.className = `message-card bg-white p-4 rounded-lg shadow border-2 border-gray-200 transition duration-150 ease-in-out`;
                            sensorCardEl.innerHTML = `
                                <div class="flex justify-between items-start">
                                    <p class="text-sm font-semibold text-gray-500 mb-1">${sensor.name}</p>
                                    <span id="${sensorId}-time" class="text-xs text-gray-400">${latestTime}</span>
                                </div>
                                <p id="${sensorId}-message" class="text-lg font-medium text-gray-800 break-words mt-1 h-12 overflow-hidden">
                                    ${latestMessage}
                                </p>
                            `;
                            gridEl.appendChild(sensorCardEl);
                        } else {
                            // Patch bestaande tekst kaart
                            const messageEl = document.getElementById(`${sensorId}-message`);
                            const timeEl = document.getElementById(`${sensorId}-time`);
                            
                            if (messageEl) messageEl.textContent = latestMessage;
                            if (timeEl) timeEl.textContent = latestTime;
                        }
                    } else {
                        // --- NUMERIEKE SENSOR KAART RENDERING (Bestaande logica) ---
                        const isSelected = selectedSensors.some(s => makeSensorKey(s.category, s.name) === makeSensorKey(category, sensor.name));
                        
                        const sensorValue = sensor.history.length > 0 ? sensor.history[sensor.history.length - 1].value : 'N/A';
                        const valueColor = (typeof sensorValue === 'number' && sensor.maxRange && sensorValue > (sensor.maxRange * 0.8)) ? 'text-red-600' : 'text-green-600';
                        const unitText = sensor.unit ? sensor.unit : '';

                        // Icoon SVG voor een grafiek (Groen als geselecteerd, anders grijs)
                        const chartIconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-line-chart ${isSelected ? 'text-emerald-500' : 'text-gray-400'}"><path d="M3 3v18h18"/><path d="m18 8-5 5-4-4-5 5"/></svg>`;

                        if (!sensorCardEl || sensorCardEl.classList.contains('message-card')) {
                            // CreÃ«er NIEUWE numerieke kaart of vervang oude tekstkaart
                            if (sensorCardEl) sensorCardEl.remove();

                            sensorCardEl = document.createElement('div');
                            sensorCardEl.id = sensorId;
                            sensorCardEl.setAttribute('data-action', 'toggle-select');
                            sensorCardEl.setAttribute('data-name', sensor.name);
                            sensorCardEl.setAttribute('data-category', category);

                            sensorCardEl.className = `sensor-card bg-white p-4 rounded-lg shadow border-2 border-gray-200 cursor-pointer transition duration-150 ease-in-out hover:shadow-lg ${isSelected ? 'sensor-card-selected' : ''}`;
                            sensorCardEl.innerHTML = `
                                <div class="flex justify-between items-start">
                                    <p class="text-sm font-semibold text-gray-500 mb-1">${sensor.name}</p>
                                    <div id="${sensorId}-icon" class="p-1">
                                        ${chartIconSvg}
                                    </div>
                                </div>
                                <div class="flex items-baseline justify-between">
                                    <span id="${sensorId}-value" class="text-4xl font-extrabold ${valueColor}">
                                        ${sensorValue}
                                    </span>
                                    <span id="${sensorId}-unit" class="text-xl font-medium text-gray-600">
                                        ${unitText}
                                    </span>
                                </div>
                                <div class="mt-2 text-xs text-gray-400">
                                    Bereik: ${sensor.minRange} - ${sensor.maxRange} ${unitText}
                                </div>
                            `;
                            gridEl.appendChild(sensorCardEl);
                        } else {
                            // Patch (BIJWERKEN) van de bestaande numerieke kaart
                            const valueEl = document.getElementById(`${sensorId}-value`);
                            const unitEl = document.getElementById(`${sensorId}-unit`);
                            const iconEl = document.getElementById(`${sensorId}-icon`);

                            // Update selectie status van de kaart
                            sensorCardEl.classList.toggle('sensor-card-selected', isSelected);

                            // Update selectie icoon met groene/grijze grafiek
                            if (iconEl) {
                                iconEl.innerHTML = chartIconSvg;
                            }

                            if (valueEl) {
                                valueEl.textContent = sensorValue;
                                valueEl.className = `text-4xl font-extrabold ${valueColor}`;
                            }
                            if (unitEl) {
                                unitEl.textContent = unitText;
                            }
                        }
                    }
                });
            });
        }


        /**
         * Toont een zwevende (toast) melding aan de gebruiker.
         */
        function showMessage(message, isError = false) {
            // Wis vorige timer
            if (toastTimeout) {
                clearTimeout(toastTimeout);
            }

            // Stel tekst en stijl in
            toastTextEl.textContent = message;
            toastNotificationEl.classList.remove('bg-red-100', 'border-red-400', 'text-red-700', 'bg-green-100', 'border-green-400', 'text-green-700', 'hidden');
            
            if (isError) {
                toastNotificationEl.classList.add('bg-red-100', 'border-l-4', 'border-red-500', 'text-red-700');
            } else {
                toastNotificationEl.classList.add('bg-green-100', 'border-l-4', 'border-green-500', 'text-green-700');
            }

            // Toon de melding
            toastNotificationEl.classList.add('show');
            
            // Verberg de melding na 5 seconden
            toastTimeout = setTimeout(() => {
                toastNotificationEl.classList.remove('show');
                setTimeout(() => {
                    if (toastNotificationEl.classList.contains('show')) return;
                    toastNotificationEl.classList.add('hidden');
                }, 300); // Wacht op de CSS transitie om te eindigen
            }, 5000);
        }

        /**
         * Verwerkt een enkele JSON string regel van de seriÃ«le poort.
         */
        function processSensorData(jsonLine) {
            try {
                const data = JSON.parse(jsonLine.trim());

                if (data.command === "SETTINGS_DEFINITION" && data.settings) {
                    processSettingsDefinition(data.settings);
                    return;
                }
                
                // Controleer op minimale vereisten voor OF numerieke data OF een bericht
                const isMessage = typeof data.message !== 'undefined';
                const isSensorData = data.name && data.category && (typeof data.value !== 'undefined' || isMessage);
                
                if (!isSensorData) {
                    // Stille waarschuwing voor onvolledige of onbekende data
                    return;
                }

                const dataType = isMessage ? 'text' : 'numeric';
                const category = data.category;
                const name = data.name;
                const timestamp = Date.now();
                
                // Belangrijk: haal de waarde of het bericht op
                const newValueOrMessage = isMessage ? data.message : data.value;
                const key = makeSensorKey(category, name);

                if (!sensorData[category]) {
                    sensorData[category] = [];
                }

                let existingSensor = sensorData[category].find(s => s.name === name);

                if (!existingSensor) {
                    existingSensor = {
                        ...data,
                        type: dataType, // <-- Belangrijke Type indicator
                        history: [],
                    };
                    if (dataType === 'numeric') {
                        // Zorg ervoor dat deze velden bestaan, zelfs als ze ontbreken in de eerste payload
                        existingSensor.minRange = existingSensor.minRange || 0;
                        existingSensor.maxRange = existingSensor.maxRange || 100;
                        existingSensor.unit = existingSensor.unit || '';
                        
                        existingSensor.minObserved = newValueOrMessage;
                        existingSensor.maxObserved = newValueOrMessage;
                    }
                    sensorData[category].push(existingSensor);
                    showMessage(`Nieuw ${dataType === 'text' ? 'bericht' : 'sensor'} toegevoegd: ${name} (${category})`, false);
                } else {
                    // Type mismatch voorkomen
                    if (existingSensor.type !== dataType) {
                        console.error(`Type mismatch for sensor ${name}. Expected ${existingSensor.type}, got ${dataType}. Skipping update.`);
                        return;
                    }
                    // Update bestaande metadata. We gebruiken Object.assign om eenheden, min/max ranges bij te werken
                    Object.assign(existingSensor, data);
                }
                
                // Geschiedenis update voor beide typen
                existingSensor.history.push({ time: timestamp, value: newValueOrMessage });

                if (existingSensor.history.length > 1000) {
                    existingSensor.history.shift();
                }

                // Alleen numerieke updates
                if (dataType === 'numeric') {
                    if (newValueOrMessage < existingSensor.minObserved) {
                        existingSensor.minObserved = newValueOrMessage;
                    }
                    if (newValueOrMessage > existingSensor.maxObserved) {
                        existingSensor.maxObserved = newValueOrMessage;
                    }
                    
                    // Grafiek update logica
                    if (activeChart && selectedSensors.some(s => makeSensorKey(s.category, s.name) === key)) {
                        const activeDuration = document.querySelector('#timescaleButtons button.bg-indigo-600')?.getAttribute('data-duration') || '60000';
                        updateChart(activeDuration);
                    }
                }

                needsRender = true;
                throttleRenderUI();

            } catch (e) {
                console.error("Fout bij het parsen van JSON:", e, "Regel:", jsonLine);
            }
        }
        
        // ----------------------------------------------------
        // Instellingen Definitie en Rendering (Nieuw)
        // ----------------------------------------------------
        
        /**
         * Verwerkt de inkomende instellingen definitie van het apparaat.
         */
        function processSettingsDefinition(settingsArray) {
            settingsDefinition = {};
            settingsChanged.clear(); 
            
            settingsArray.forEach(setting => {
                if (setting.id) {
                    settingsDefinition[setting.id] = {
                        ...setting,
                        originalValue: setting.value // Sla de originele waarde op voor vergelijking
                    };
                }
            });
            
            showMessage(`Instellingsdefinities geladen. ${settingsArray.length} parameters beschikbaar.`, false);
            renderSettingsControls();
        }
        
        /**
         * Render de dynamische instellingen besturingselementen.
         */
        function renderSettingsControls() {
            const ids = Object.keys(settingsDefinition);
            settingsContainerEl.innerHTML = '';
            
            if (ids.length === 0) {
                settingsContainerEl.appendChild(initialSettingsMessageEl);
                initialSettingsMessageEl.classList.remove('hidden');
                sendSettingsButtonEl.disabled = true;
                return;
            }
            
            initialSettingsMessageEl.classList.add('hidden');
            
            ids.forEach(id => {
                const setting = settingsDefinition[id];
                const isChanged = settingsChanged.has(id);
                
                const card = document.createElement('div');
                card.className = `p-4 border border-gray-200 rounded-lg shadow-sm transition duration-150 ${isChanged ? 'setting-changed' : 'bg-white'}`;
                card.id = `setting-card-${id}`;
                card.innerHTML = `
                    <label for="input-${id}" class="block text-sm font-medium text-gray-700 mb-2">
                        ${setting.label} (${id})
                    </label>
                    <div id="control-wrapper-${id}" class="flex items-center space-x-2">
                        </div>
                `;
                
                const controlWrapper = card.querySelector(`#control-wrapper-${id}`);
                let inputElement;

                // Dynamisch het juiste invoertype creÃ«ren
                if (setting.type === 'value' || setting.type === 'text') {
                    inputElement = document.createElement('input');
                    inputElement.id = `input-${id}`;
                    inputElement.name = id;
                    inputElement.className = 'flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm';
                    inputElement.value = setting.value;
                    inputElement.onchange = (e) => handleSettingChange(id, e.target.value);

                    if (setting.type === 'value') {
                        inputElement.type = 'number';
                        inputElement.min = setting.min !== undefined ? setting.min : '';
                        inputElement.max = setting.max !== undefined ? setting.max : '';
                        inputElement.step = setting.step !== undefined ? setting.step : 'any';
                    } else if (setting.type === 'text') {
                        inputElement.type = 'text';
                        inputElement.maxLength = setting.maxLength || 255;
                    }

                    controlWrapper.appendChild(inputElement);
                    
                    if (setting.unit) {
                        const unitSpan = document.createElement('span');
                        unitSpan.className = 'text-sm text-gray-500 whitespace-nowrap';
                        unitSpan.textContent = setting.unit;
                        controlWrapper.appendChild(unitSpan);
                    }
                    
                } else if (setting.type === 'select') {
                    inputElement = document.createElement('select');
                    inputElement.id = `input-${id}`;
                    inputElement.name = id;
                    inputElement.className = 'flex-grow px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm';
                    inputElement.onchange = (e) => handleSettingChange(id, e.target.value);
                    
                    setting.options.forEach(option => {
                        const optionEl = document.createElement('option');
                        optionEl.value = option.key;
                        optionEl.textContent = option.label;
                        if (option.key == setting.value) {
                            optionEl.selected = true;
                        }
                        inputElement.appendChild(optionEl);
                    });
                    
                    controlWrapper.appendChild(inputElement);
                }
                
                settingsContainerEl.appendChild(card);
            });
            
            // Update de status van de "Update Instellingen" knop
            updateSendSettingsButton();
        }
        
        /**
         * Behandelt een wijziging in een instelling.
         */
        function handleSettingChange(id, newValue) {
            const setting = settingsDefinition[id];
            
            // Converteer de waarde naar het juiste type (voor numerieke vergelijking)
            let typedNewValue = newValue;
            if (setting.type === 'value') {
                typedNewValue = parseFloat(newValue);
            }
            
            // Controleer of de waarde echt veranderd is ten opzichte van de originele waarde
            if (typedNewValue !== setting.originalValue) {
                settingsChanged.add(id);
                // Update de tijdelijke weergavewaarde
                settingsDefinition[id].value = typedNewValue;
            } else {
                settingsChanged.delete(id);
            }
            
            // Visuele feedback op de kaart
            const cardEl = document.getElementById(`setting-card-${id}`);
            if (cardEl) {
                cardEl.classList.toggle('setting-changed', settingsChanged.has(id));
            }

            updateSendSettingsButton();
        }

        /**
         * Update de status van de "Update Instellingen" knop.
         */
        function updateSendSettingsButton() {
            const count = settingsChanged.size;
            sendSettingsButtonEl.textContent = `Update Instellingen (${count})`;
            sendSettingsButtonEl.disabled = count === 0 || !isConnected;
        }

        /**
         * Verzendt alle gewijzigde instellingen naar de seriÃ«le poort.
         */
        window.sendAllChangedSettings = async function() {
            if (settingsChanged.size === 0) return;
            if (!writer) {
                showMessage("Geen seriÃ«le verbinding beschikbaar om data te verzenden.", true);
                return;
            }

            const encoder = new TextEncoder();
            const changedSettingsArray = Array.from(settingsChanged);
            
            for (const id of changedSettingsArray) {
                const setting = settingsDefinition[id];
                const valueToSend = setting.value;
                
                const updatePayload = {
                    command: "SET",
                    id: id,
                    value: valueToSend
                };
                
                const jsonString = JSON.stringify(updatePayload) + '\n';
                
                try {
                    await writer.write(encoder.encode(jsonString));
                    
                    // Markeer als verzonden door de originele waarde bij te werken
                    setting.originalValue = valueToSend;
                    settingsChanged.delete(id);
                    
                    // Verwijder de visuele feedback
                    const cardEl = document.getElementById(`setting-card-${id}`);
                    if (cardEl) {
                        cardEl.classList.remove('setting-changed');
                    }
                    
                    console.log(`Verzonden: ${jsonString.trim()}`);
                    
                } catch (e) {
                    showMessage(`Fout bij verzenden van instelling ${id}: ${e.message}`, true);
                    break; 
                }
            }
            
            showMessage(`${changedSettingsArray.length} instelling(en) succesvol bijgewerkt.`, false);
            updateSendSettingsButton();
        }


        // ----------------------------------------------------
        // SeriÃ«le Lezen/Schrijven Logica
        // ----------------------------------------------------

        /**
         * Stuurt een JSON-object als een JSON string, gevolgd door een newline,
         * naar de seriÃ«le poort.
         * @param {object} data - Het te verzenden JSON-object.
         */
        async function sendSerialData(data) {
            if (!writer) {
                showMessage("Fout: Kan geen data verzenden. SeriÃ«le poort is niet open.", true);
                return;
            }

            const encoder = new TextEncoder();
            const jsonString = JSON.stringify(data) + '\n';
            
            try {
                await writer.write(encoder.encode(jsonString));
                console.log(`Verzonden: ${jsonString.trim()}`);
            } catch (e) {
                showMessage(`Fout bij verzenden van commando: ${e.message}`, true);
            }
        }

        /**
         * Leest data van de seriÃ«le poort.
         */
        async function readSerialPort() {
            isConnected = true; 
            toggleDataStale();  // ZET VERVAGING UIT

            updateStatus('Verbonden en leest data...', 'connected');
            connectButton.textContent = 'Verbreken';
            // BAUD RATE VERBERGEN
            baudRateWrapperEl.classList.add('hidden'); 
            
            writer = port.writable.getWriter(); // Maak een writer klaar
            
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            
            reader = textDecoder.readable
                .pipeThrough(new TransformStream(new LineBreakTransformer()))
                .getReader();

            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        break;
                    }
                    processSensorData(value);
                }
            } catch (error) {
                if (error.name !== 'InvalidStateError') {
                   showMessage(`Leesfout: ${error.message}`, true);
                   updateStatus(`Leesfout: ${error.message}`, 'error');
                }
            } finally {
                if (reader) {
                    reader.releaseLock();
                    reader = null;
                }
                
                if (writer) { // Sluit de writer af
                    writer.releaseLock();
                    writer = null;
                }
                
                await readableStreamClosed.catch(() => { /* Negeer fout bij sluiten */ });
                port = null;
                connectButton.textContent = 'Verbind';
                updateStatus('Klaar om te verbinden.', 'default');
                // BAUD RATE TONEN
                baudRateWrapperEl.classList.remove('hidden'); 
                showMessage('Verbinding verbroken. Data is nu statisch en vervaagd.', false);
                
                isConnected = false; // ZET STATUS OP VERBROKEN
                toggleDataStale();  // ZET VERVAGING AAN
                updateSendSettingsButton(); // Update knop status

                if (renderTimeout) {
                    clearTimeout(renderTimeout);
                    renderTimeout = null;
                    needsRender = false;
                }
            }
        }

        /**
         * Transformer Klasse om de inkomende stream op regels te splitsen.
         */
        class LineBreakTransformer {
            constructor() {
                this.chunks = '';
            }

            transform(chunk, controller) {
                this.chunks += chunk;
                const lines = this.chunks.split('\n');
                this.chunks = lines.pop();
                lines.forEach(line => controller.enqueue(line));
            }

            flush(controller) {
                controller.enqueue(this.chunks);
            }
        }


        /**
         * Vraagt de gebruiker om een seriÃ«le poort te selecteren en maakt verbinding.
         */
        window.connectSerialPort = async function() {
            if (port) {
                // Verbreek de verbinding
                if (reader) {
                    await reader.cancel(); 
                }
                return;
            }

            if (!('serial' in navigator)) {
                showMessage('Web Serial API wordt niet ondersteund in deze browser. Gebruik Chrome, Edge of Opera.', true);
                updateStatus('API niet ondersteund.', 'error');
                return;
            }

            try {
                connectButton.disabled = true;
                updateStatus('Wacht op poort selectie...', 'connecting');

                const baudRate = parseInt(baudRateSelectEl.value, 10);

                port = await navigator.serial.requestPort({ filters: [] });

                await port.open({ baudRate: baudRate });

                updateStatus('Verbinding tot stand gebracht. Start lezen...', 'connected');
                connectButton.disabled = false;
                
                // BAUD RATE VERBERGEN BIJ SUCCES
                baudRateWrapperEl.classList.add('hidden'); 
                
                readSerialPort();
                updateSendSettingsButton();
                
                // ðŸŒŸ TOEVOEGING: Vraag Instellingen op na verbinding (L723) ðŸŒŸ
                await sendSerialData({ command: "REQUEST_SETTINGS" });

            } catch (error) {
                connectButton.disabled = false;
                
                if (error.name === 'NotFoundError') {
                    showMessage('Geen seriÃ«le poort geselecteerd.', true);
                    updateStatus('Klaar om te verbinden.', 'default');
                } else {
                    showMessage(`Verbindingsfout: ${error.message}`, true);
                    updateStatus('Fout: ' + error.message, 'error');
                }
                port = null; 
                connectButton.textContent = 'Verbind';
                // BAUD RATE TONEN BIJ FOUT
                baudRateWrapperEl.classList.remove('hidden'); 
            }
        }

        /**
         * Opent de modal en toont de grafiek voor de geselecteerde sensoren.
         */
        window.openMultiSensorGraph = function() {
            if (selectedSensors.length === 0) {
                showMessage("Selecteer minimaal Ã©Ã©n sensor om een grafiek te tonen.", true);
                return;
            }

            document.getElementById('graphModal').classList.remove('hidden');

            // Standaard tijdschaal: 1 minuut (60000 ms)
            updateChart('60000');
        };

        // ------------------------------------------------------------------
        // EVENT DELEGATION voor Sensor Selectie
        // ------------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            sensorContainerEl.addEventListener('click', (event) => {
                let targetCard = event.target.closest('[data-action="toggle-select"]');

                if (targetCard) {
                    event.preventDefault(); 
                    
                    const name = targetCard.getAttribute('data-name');
                    const category = targetCard.getAttribute('data-category');

                    if (name && category) {
                        toggleSensorSelection(category, name);
                    }
                }
            });
        });

        // ------------------------------------------------------------------
        // GRAFIEK LOGICA (Aangepast voor multi-dataset)
        // ------------------------------------------------------------------
        
        /**
         * Sluit de grafiek modal.
         */
        window.closeGraphModal = function() {
            document.getElementById('graphModal').classList.add('hidden');
            if (activeChart) {
                activeChart.destroy();
                activeChart = null;
            }
            // Reset knopstijlen
            document.querySelector('#timescaleButtons button[data-duration="60000"]').classList.add('bg-indigo-600', 'text-white');
            document.querySelectorAll('#timescaleButtons button:not([data-duration="60000"])').forEach(btn => {
                btn.classList.remove('bg-indigo-600', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });
        };

        /**
         * Bouwt de legenda van de grafiek.
         */
        function buildLegend(datasets) {
            let html = '<p class="font-semibold mb-2 text-gray-700">Geselecteerde Sensoren:</p><div class="flex flex-wrap gap-4">';
            
            datasets.forEach(dataset => {
                const color = dataset.borderColor;
                const name = dataset.label;
                html += `
                    <div class="flex items-center space-x-2">
                        <span class="w-3 h-3 rounded-full" style="background-color: ${color};"></span>
                        <span class="text-sm text-gray-700">${name}</span>
                    </div>
                `;
            });

            html += '</div>';
            chartLegendEl.innerHTML = html;
        }


        /**
         * Filtert data en tekent de grafiek.
         * @param {string} durationMs - De tijdsduur in milliseconden ('60000', '300000', etc.).
         */
        window.updateChart = function(durationMs) {
            if (selectedSensors.length === 0) return;
            
            const now = Date.now();
            const timeLimit = now - parseInt(durationMs, 10);
            
            let datasets = [];
            let allLabels = [];
            let minY = Infinity;
            let maxY = -Infinity;

            // 1. Maak datasets voor elke geselecteerde sensor
            selectedSensors.forEach((sRef, index) => {
                const sensor = getSensorByKey(makeSensorKey(sRef.category, sRef.name));
                if (!sensor || sensor.type !== 'numeric') return; 

                const filteredData = sensor.history.filter(point => point.time >= timeLimit);
                const dataValues = filteredData.map(point => point.value);
                
                dataValues.forEach(val => {
                    if (val < minY) minY = val;
                    if (val > maxY) maxY = val;
                });

                if (index === 0) {
                    allLabels = filteredData.map(point => new Date(point.time).toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                }

                const color = CHART_COLORS[index % CHART_COLORS.length];

                datasets.push({
                    label: `${sensor.name} (${sensor.unit || 'waarde'})`,
                    data: dataValues,
                    borderColor: color,
                    backgroundColor: color,
                    borderWidth: 2,
                    pointRadius: 0, 
                    tension: 0.1,
                    fill: false, 
                    yAxisID: 'y' 
                });
            });

            // 2. Bepaal de definitieve schaal met padding
            const range = maxY - minY;
            const padding = range * 0.05 || (minY === maxY ? 0.5 : 1); 
            const finalMinY = minY === Infinity ? 0 : minY - padding;
            const finalMaxY = maxY === -Infinity ? 100 : maxY + padding;

            // 3. Bouw of update de Chart.js instantie
            if (activeChart) {
                activeChart.data.labels = allLabels;
                activeChart.data.datasets = datasets;
                activeChart.options.scales.y.min = finalMinY;
                activeChart.options.scales.y.max = finalMaxY;
                activeChart.options.plugins.title.text = `Laatste ${parseInt(durationMs, 10) / 60000} Minuut${parseInt(durationMs, 10) === 60000 ? '' : 'en'} (Meerdere Sensoren)`;
                activeChart.update();

            } else {
                const ctx = document.getElementById('sensorChart').getContext('2d');
                activeChart = new Chart(ctx, {
                    type: 'line', // Zorg ervoor dat het een lijngrafiek blijft
                    data: {
                        labels: allLabels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            y: {
                                beginAtZero: false,
                                min: finalMinY,
                                max: finalMaxY,
                                title: {
                                    display: true,
                                    text: 'Waarde',
                                    font: { size: 14, weight: 'bold' }
                                }
                            },
                            x: {
                                ticks: {
                                    maxTicksLimit: 10
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: true,
                                text: `Laatste ${parseInt(durationMs, 10) / 60000} Minuut${parseInt(durationMs, 10) === 60000 ? '' : 'en'} (Meerdere Sensoren)`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });
            }
            
            // 4. Update de handmatige legenda
            buildLegend(datasets);

            // 5. Update actieve knop stijl
            document.querySelectorAll('#timescaleButtons button').forEach(btn => {
                btn.classList.remove('bg-indigo-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });
            document.querySelector(`#timescaleButtons button[data-duration="${durationMs}"]`).classList.add('bg-indigo-600', 'text-white', 'shadow-md');
        };
        
        // ------------------------------------------------------------------
        // CSV EXPORT LOGICA
        // ------------------------------------------------------------------

        /**
         * Downloadt de volledige ruwe historische data voor alle geselecteerde sensoren.
         */
        window.downloadRawSelectedData = function() {
            if (selectedSensors.length === 0) {
                showMessage("Geen sensoren geselecteerd om te exporteren.", true);
                return;
            }

            const csvRows = [];
            // CSV Headers
            csvRows.push("Timestamp (ms),Tijd (ISO),Categorie,Naam,Waarde,Eenheid");

            let allDataPoints = [];

            // 1. Verzamel alle historische data voor geselecteerde sensoren
            selectedSensors.forEach(sRef => {
                const sensor = getSensorByKey(makeSensorKey(sRef.category, sRef.name));
                if (sensor && sensor.type === 'numeric') {
                    // Gebruik de volledige historie, ongeacht de huidige grafiek filtering
                    sensor.history.forEach(point => {
                        allDataPoints.push({
                            time: point.time,
                            category: sRef.category,
                            name: sRef.name,
                            value: point.value,
                            unit: sensor.unit || '',
                        });
                    });
                }
            });
            
            if (allDataPoints.length === 0) {
                 showMessage("Geen datapunten in de geschiedenis om te exporteren.", true);
                 return;
            }

            // 2. Sorteer alle punten op tijdstempel
            allDataPoints.sort((a, b) => a.time - b.time);

            // 3. Converteer naar CSV-rijen
            allDataPoints.forEach(p => {
                // Gebruik ISO-tijd voor een eenduidige, wereldwijde tijdsaanduiding
                const timeString = new Date(p.time).toISOString(); 
                
                // Zorg ervoor dat strings (categorie/naam/eenheid) correct worden geciteerd en escapet
                const row = [
                    p.time,
                    timeString,
                    `"${p.category.replace(/"/g, '""')}"`,
                    `"${p.name.replace(/"/g, '""')}"`,
                    p.value,
                    `"${p.unit.replace(/"/g, '""')}"`
                ].join(',');
                
                csvRows.push(row);
            });

            const csvString = csvRows.join('\n');
            
            // 4. Download logic
            const now = new Date();
            const dateString = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            const filename = `SensorData_Export_${dateString}.csv`;
            
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage(`Data van ${allDataPoints.length} punten geÃ«xporteerd naar ${filename}`, false);
            } else {
                showMessage("Download is niet ondersteund in deze browser.", true);
            }
        }


        // Initieel de UI renderen en de vervaging aanzetten
        updateSensorDisplays();
        updateChartButtonState();
        toggleDataStale(); // Start in verbroken (vervaagde) staat
        setActiveTab('monitor'); // Start op de monitor tab

    </script>
</body>
</html>